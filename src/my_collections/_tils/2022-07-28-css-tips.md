---
layout: post
title: "CSS Tips: CSS reset at the component level"

meta:
  categories: [CSS]
  date: 2022-07-25T18:00:00Z
  ert: 5
---

Custom variables to rule them all

Manually Increasing the base font-size and leading on

Don't 

```css
body {
  font-size: var(--typescale-base-text-small);
  line-height: var(--leading-lager);
}


// MQs 
@include respond(tablet-large) {
  body {
    font-size: var(--typescale-base-text-medium);
    line-height: var(--leading-largest);
  }
}
```

Do

```css
:root {
    --base-font-size: var(--typescale-base-text-small);
  	--base-line-height: var(--leading-lager);
}

// MQs 
@include respond(tablet-large) {
  --base-font-size: var(--typescale-base-text-medium);
  --base-line-height: var(--leading-largest);
}

body {
  font-size: var(--base-font-size);
  line-height: var(--base-line-height);
}
```



## Don't add any variable that is not in use

Don't add any variable that you are not using at the moment of writing code. Don't fall for this idea of, this is nice, I will use this letter, let me add it, No don't add it, add it if you need it now, not letter.

If you are afraid you will the nice name of the variable - keep it aside on a CSS dev note 



## Reduces a lot of utitility classes 

One common example is the leading text that is use on blockquotations and other places such as important text.



example

```css
.ut-lead-text {
  font-size: var(--typescale-base-text-large);
}

@include respond(tablet-large) {
  .ut-lead-text {
    font-size: var(--typescale-title-text-medium);
  }
}
```



bring the example of the blockquote

```css
blockquote {
  font-size: var(--lead-text);
}

@include respond(tablet-large) {
  blockquote {
    --lead-text: var(--typescale-title-small);
  }
}
```







Check your previous codes on how your name you variables (like having a lot predefined variables names you and it becomes complicated you soon run out what name to give -  )









Uniformity of containers

```css
  .ob-contain--size-pageless {
    max-width: 100%;
    padding-inline-start: 0;
    padding-inline-end: 0;
  }
```



But if both the paragraph and the button have a handler, the more specific handler—the one on the button—gets to go first.





UTG theme switcher

```css
  .cp-theme-switcher--white {
    
    border-color: var(--white-light);

    .cp-theme-switcher__button {
      background: var(--white-light);
      border-color: var(--white-light);

      &:hover {
        border-color: var(--white);
        background: var(--white);
      }
    }

    .cp-theme-switcher__icon {
      fill: var(--black);
    }

    &:hover {
      border-color: var(--white);
    }
  } 

```

```
  // Block Modifiers
  .cp-masthead--media-overlay {
    .cp-masthead__figure {
      @include pos-zero-all-sides;
      position: absolute;
      &::after {
        @include pseudo-class;
        @include pos-zero-all-sides;
        position: absolute;
        background-color: var(--transparent-neutral-medium); 
      }
    }
  }

  .cp-masthead--media-aside {
    .cp-masthead__figure {
      //position: absolute; // the image should be contain with this
      background-color: transparent;
    }
  }
```







Note that the "mousemove" handler is registered on the whole window. Even if the mouse goes outside of the bar during resizing, as long as the button is held we still want to update its size.
We must stop resizing the bar when the mouse button is released. For that, we can use the buttons property (note the plural), which tells us about the
buttons that are currently held down. When this is zero, no buttons are down.
When buttons are held, its value is the sum of the codes for those buttons—the

Note that the order of these codes is different from the one used by button,
where the middle button came before the right one. As mentioned, consistency
isn’t really a strong point of the browser’s programming interface..
